---
title: "New cimDiablo version"
author: "MARDOC Emile"
date: "02/10/2020"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(mixOmics)
```

https://mixomics-users.discourse.group/t/cim-for-blockpls/340


Dear mixOmics members,

My name is Emile Mardoc and I am a french student. I work at the INRAE
of Clermont-Ferrand for months and use mixOmics to integrate omics data.

A few weeks ago, I sent a message on your forum about several questions
I had during my use of some tools, especially N-integrative tools. I
created then two new versions of cimDiablo, and Kim-Anh LÃª Cao asked me
to send you "a reproducible code + qualitative comparison on the classic
heat map vs [my] approach on the breast cancer data set".

Here are my code, plots and interpretations!

Don't hesitate to contact me if you need more explanations.

Best regards,
Emile Mardoc

# My functions

## cimDiablo_v3

Note: this function is very inspired by the mixOmics "cimDiablo" function. Here is the main difference:

* cimDiablo_v3 uses the "cim" function on new data which are computed using outputs of "block.splsda", where cimDiablo uses the "cim" function on initial data which are inputs of "block.splsda". This part of the code is separated from the others by two rows of "#".

input:

* object: result of the mixOmics function "block.splsda"

input example:

* object = block.pls(X = data1, Y = data2, ncomp = 3, design = matrix(1, nrow = length(X), ncol = length(X)))

outputs:

* a CIM graph where rows and columns' names are as those from the initial data matrix. Values are computed using the "cim" function

* an invisble output containing results of the "cim" function
    
```{r}
cimDiablo_v3 = function(object,
                        use_comp = FALSE,
                        color = NULL,
                        color.Y,
                        color.blocks,
                        comp = NULL,
                        margins = c(2, 15),
                        legend.position="topright",
                        transpose = FALSE,
                        row.names = TRUE,
                        col.names = TRUE,
                        size.legend = 1.5)
{
  library(RColorBrewer)
    
    # check input object
    if (!any(class(object) == "block.splsda"))
    stop("cimDiablo is only available for 'block.splsda' objects")

    if (length(object$X) <= 1)
    stop("This function is only available when there are more than 3 blocks") 
            # so 2 blocks in X + the outcome Y
  
    ncomp = min(object$ncomp)
    #-- comp
    if(is.null(comp))
      {comp = 1:ncomp}
    if (length(comp) > 1) {
      comp = unique(comp)
      if (!is.numeric(comp) || any(comp < 1))
          stop("invalid vector for 'comp'.", call. = FALSE)
      if (any(comp > ncomp))
          stop("the elements of 'comp' must be smaller or equal than ", ncomp, ".",
               call. = FALSE)
    }
    
    if (length(comp) == 1) {
        if (is.null(comp) || !is.numeric(comp) || comp <= 0 || comp > ncomp)
        stop("invalid value for 'comp'.", call. = FALSE)
        comp=c(comp,comp)
    }
    
    comp = round(comp)
    
    # color
    if(missing(color.Y))
    {
        color.Y = color.mixo(1:nlevels(object$Y))
    } else {
        if(length(color.Y) != nlevels(object$Y))
        stop("'color.Y' needs to be of length ", nlevels(object$Y))
    }
    
    if(missing(color.blocks))
    {
        color.blocks = brewer.pal(n = 12, name = 'Paired')[seq(2, 12, by = 2)]
    } else {
        if(length(color.blocks) != length(object$X))
        stop("'color.blocks' needs to be of length ", length(object$X))
    }
    
    X = object$X
    Y = object$Y
    
    #need to reorder variates and loadings to put 'Y' in last
    indY = object$indY
    object$variates = c(object$variates[-indY], object$variates[indY])
    object$loadings = c(object$loadings[-indY], object$loadings[indY])

    #####################################################################################
    #compute the unbiaised original signal by using final components of mixOmics methods
    if (use_comp){ #use comp (from input or defined as 1:min(ncomp))
    #reducing loadings for ncomp
        object$loadings = lapply(object$loadings, function(x){x[, comp, drop=FALSE]})
        XDatList <- sapply(1:(length(object$variates)-1), function(i) 
          object$variates[[i]][,comp] %*% t(object$loadings[[i]])[comp,])
    }
    else{ #use all components available
        XDatList <- sapply(1:(length(object$variates)-1), function(i) object$variates[[i]] 
                           %*% t(object$loadings[[i]])[1:ncol(object$variates[[i]]),])
    }
    #####################################################################################
    
    keepA = lapply(object$loadings, function(i) apply(abs(i), 1, sum) > 0)
    
    XDatList = mapply(function(x, y){
    x[, y]
    }, x=XDatList, y=keepA[-length(keepA)], SIMPLIFY=FALSE)
    
    XDat = do.call(cbind, XDatList)
    XDat[which(XDat > 2)] = 2
    XDat[which(XDat < -2)] = -2
    
    VarLabels = factor(rep(names(X), lapply(keepA[-length(keepA)], sum)), levels = 
                         names(X))
    
    ## Plot heatmap
    opar = par()[! names(par()) %in% c("cin", "cra", "csi", "cxy", "din", "page")]
    par(mfrow=c(1,1))
    cim.res <- cim(XDat,transpose= transpose, color = color,
      row.names = row.names, col.names = col.names,
      col.sideColors = color.blocks[as.numeric(VarLabels)],
      row.sideColors = color.Y[as.numeric(Y)], margins = margins)
    
    if(!transpose)
    {
        legend(legend.position,
        c("Rows", c(levels(Y)[order(levels(Y))], "", "Columns", names(X))),
        col = c(1, color.Y, 1, 1, color.blocks[1:nlevels(VarLabels)][match(levels(
          VarLabels), names(X))]),
        pch = c(NA, rep(19, nlevels(Y)), NA, NA, rep(19, nlevels(VarLabels))),
        bty="n",
        cex = size.legend,
        text.font = c(2, rep(1, nlevels(Y)), NA, 2, rep(1, nlevels(VarLabels))))

    } else { # if transpose == TRUE, rows and columns must be switched
        legend(legend.position,
        c("Rows", names(X), "", "Columns", c(levels(Y)[order(levels(Y))])),
        col = c(1, color.blocks[1:nlevels(VarLabels)][match(levels(VarLabels), 
                                                            names(X))], 1, 1, color.Y),
        pch = c(NA, rep(19, nlevels(VarLabels)), NA, NA, rep(19, nlevels(Y))),
        bty="n",
        cex = size.legend,
        text.font = c(2, rep(1, nlevels(VarLabels)), NA, 2, rep(1, nlevels(Y))))
        
    }
    par(opar)
    
    
    return(invisible(cim.res))
}
```

## cimDiablo_v2

Note: this function is very inspired by the mixOmics "cimDiablo" function. 

Here are the two main differences:

* cimDiablo_v2's input is a "block.pls" or "block.spls" object, where cimDiablo's input is a "block.splsda" object.

* cimDiablo_v2 uses the "cim" function on new data which are computed using outputs of "block.pls" or "block.spls", where cimDiablo uses the "cim" function on initial data which are inputs of "block.pls" or "block.spls". This part of the code is separated from the others by two rows of "#".


input:

* object: result of the mixOmics function "block.pls" or "block.spls".

input example:


* object = block.pls(X = data, indY = 2, ncomp = 3, design = matrix(1, nrow = length(X), ncol = length(X)))

outputs:

* a CIM graph where rows and columns' names are those from the initial data matrix. Values are computed using the "cim" function.

* an invisble output containing results of the "cim" function.

```{r}
cimDiablo_v2 = function(object, use_comp = FALSE,
                     color = NULL,
                     color.blocks,
                     comp = NULL,
                     margins = c(2, 15),
                     legend.position="topright",
                     transpose = FALSE,
                     row.names = TRUE,
                     col.names = TRUE,
                     size.legend = 1.5)
{
  library(RColorBrewer)
    
  # check input object
  if (!any((class(object) == "block.pls")||(class(object) == "block.spls")))
    stop("This function is only available for 'block.pls' and 'block.spls' objects")
  
  if (length(object$X) <= 1)
    stop("This function is only available when there are 2 blocks or more")
  
  ncomp = min(object$ncomp)
  #-- comp
  if(is.null(comp))
      {comp = 1:ncomp}
  if (length(comp) > 1) {
      comp = unique(comp)
      if (!is.numeric(comp) || any(comp < 1))
          stop("invalid vector for 'comp'.", call. = FALSE)
      if (any(comp > ncomp))
          stop("the elements of 'comp' must be smaller or equal than ", ncomp, "."
               ,call. = FALSE)
  }
  
  if (length(comp) == 1) {
    if (is.null(comp) || !is.numeric(comp) || comp <= 0 || comp > ncomp)
      stop("invalid value for 'comp'.", call. = FALSE)
    comp=c(comp,comp)
  }
  
  comp = round(comp)
  
  # color
  
  if(missing(color.blocks))
  {
    color.blocks = brewer.pal(n = 12, name = 'Paired')[seq(2, 12, by = 2)]
  } else {
    if(length(color.blocks) != length(object$X))
      stop("'color.blocks' needs to be of length ", length(object$X))
  }
  

  #need to reorder variates and loadings to put 'Y' in last
  indY = object$indY
  object$variates = c(object$variates[-indY], object$variates[indY])
  object$loadings = c(object$loadings[-indY], object$loadings[indY])
  dat_names <- c(names(object$X)[-indY],names(object$X)[indY])
  
  ######################################################################################
  #compute the unbiaised original signal by using final components of mixOmics methods
  if (use_comp){ #use comp (from input or defined as 1:min(ncomp))
      #reducing loadings for ncomp
      object$loadings = lapply(object$loadings, function(x){x[, comp, drop=FALSE]})
      XDatList <- sapply(1:length(object$variates), function(i) 
        object$variates[[i]][,comp] %*% t(object$loadings[[i]])[comp,])
  }
  else{ #use all components available
      XDatList <- sapply(1:length(object$variates), function(i) object$variates[[i]] %*% 
                             t(object$loadings[[i]])[1:ncol(object$variates[[i]]),])
  }
  ######################################################################################
 
  keepA = lapply(object$loadings, function(i) apply(abs(i), 1, sum) > 0)
  XDatList = mapply(function(x, y){
    x[, y]
  }, x=XDatList, y=keepA, SIMPLIFY=FALSE)

  XDat = do.call(cbind, XDatList)
  XDat[which(XDat > 2)] = 2
  XDat[which(XDat < -2)] = -2
  
  VarLabels = factor(rep(dat_names, lapply(keepA, sum)), levels = dat_names)
  
  ## Plot heatmap
  opar = par()[! names(par()) %in% c("cin", "cra", "csi", "cxy", "din", "page")]
  par(mfrow=c(1,1))
  cim.res <- cim(XDat,transpose= transpose, color = color,
      row.names = row.names, col.names = col.names,
      col.sideColors = color.blocks[as.numeric(VarLabels)],
      margins = margins)
  
  if(!transpose)
  {
    legend(legend.position,
           c("Columns", dat_names),
           col = c(1, color.blocks[1:nlevels(VarLabels)][match(levels(VarLabels), 
                                                               dat_names)]),
           pch = c(NA, rep(19, nlevels(VarLabels))),
           bty="n",
           cex = size.legend,
           text.font = c(2, rep(1, nlevels(VarLabels))))

  } else { # if transpose == TRUE, rows and columns must be switched
    legend(legend.position,
           c("Rows", dat_names),
           col = c(1, color.blocks[1:nlevels(VarLabels)][match(levels(VarLabels), 
                                                               dat_names)]),
           pch = c(NA, rep(19, nlevels(VarLabels))),
           bty="n",
           cex = size.legend,
           text.font = c(2, rep(1, nlevels(VarLabels))))

  }
  par(opar)
  

  return(invisible(cim.res))
}
```




# Data used : breast cancer

The beginning of this part comes from mixOmics' website.

```{r}
data('breast.TCGA')
# extract training data
data = list(mRNA = breast.TCGA$data.train$mrna, 
            miRNA = breast.TCGA$data.train$mirna, 
            proteomics = breast.TCGA$data.train$protein)

# check dimension
lapply(data, dim)
```

```{r}
# outcome
Y = breast.TCGA$data.train$subtype
summary(Y)
```

```{r}
design = matrix(0.1, ncol = length(data), nrow = length(data), 
                dimnames = list(names(data), names(data)))
diag(design) = 0

design 
```

```{r}
sgccda.res = block.splsda(X = data, Y = Y, ncomp = 5, 
                           design = design)

set.seed(123) # for reproducibility, only when the `cpus' argument is not used
# this code takes a couple of min to run
perf.diablo = perf(sgccda.res, validation = 'Mfold', folds = 5, nrepeat = 3, cpus = 3)

#perf.diablo  # lists the different outputs
plot(perf.diablo) 
```

```{r}
perf.diablo$choice.ncomp$WeightedVote
```

```{r}
ncomp = perf.diablo$choice.ncomp$WeightedVote["Overall.BER", "centroids.dist"]
```

```{r}
#set.seed(123) # for reproducibility, only when the `cpus' argument is not used
test.keepX = list (mRNA = c(10:11),
                   miRNA = c(20:21),
                   proteomics = c(10:11))

tune.TCGA = tune.block.splsda(X = data, Y = Y, ncomp = ncomp, 
                              test.keepX = test.keepX, design = design,
                              validation = 'Mfold', folds = 3, nrepeat = 1,
                              BPPARAM = BiocParallel::MulticoreParam(workers = 3), dist = "centroids.dist")


list.keepX = tune.TCGA$choice.keepX
list.keepX
```



```{r}
list.keepX = list(mRNA = c(6,14), miRNA = c(5,18), proteomics = c(6,7)) # from tuning step
```


```{r}
sgccda.res = block.splsda(X = data, Y = Y, ncomp = ncomp, 
                          keepX = list.keepX, design = design)
```

```{r}
sgccda.res$design
```

```{r}
cimDiablo(sgccda.res, margins = c(15, 15), legend.position = "right", row.names = F)
```

```{r}
cimDiablo_v3(sgccda.res, margins = c(15, 15), legend.position = "right", row.names = F)
```

As you can see, there are several differences between the mixOmics version and my own. 

First, because cimDiablo_v3 deletes a large part of the noise, pseudo-correlations become smaller (colors are more yellow than red or blue). Moreover, seperations between samples/variables are clearer with the heatmap from cimDiablo_v3 than with cimDiablo heatmap.

Furthermore, by comparing the dendrograms, we see that there were not big differences between samples/variables according to cimDiablo, but now several groups of samples/variables appear. It could tend to prove that this new version is better than cimDiablo, but I don't have any knowledge about these datasets then I can't know if the groups found are consistent to those found with other methods, or if they are unexpected groups which could prove that cimDiablo_v3 doesn't work well. However, the groups found with cimDiablo_v3 with my own data were pretty good so I hope these groups from breast cancer dataset have a biological interpretation too.

Finally, there is no big difference between rows categories (Basal, Her2, LumA) for the two methods as the number of color-blocks (be careful, I don't speak here about omics blocks but about blocks of colors, which correspond to Basal, Her2 or LumA!) is quite similar, but there is a difference between columns categories (mRNA, miRNA, proteomics). Indeed, it appears that omics categories (mRNA, miRNA, proteomics) are more seperated with cimDiablo thant with cimDiablo_v3. Because I don't know breast cancer data, I can't tell if this is a good result or not...
